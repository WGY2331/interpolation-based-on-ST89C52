C51 COMPILER V9.54   DRIVE                                                                 06/17/2020 18:07:45 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE DRIVE
OBJECT MODULE PLACED IN .\Objects\drive.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE code\drive.c ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PR
                    -INT(.\Listings\drive.lst) OBJECT(.\Objects\drive.obj)

line level    source

   1          #include"drive.h"
   2          
   3          #define FOSC 11059200UL     //System frequency
   4          #define BAUD 9600       //UART baudrate
   5          
   6          uchar code table[] = { 0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09 };//正
   7          
   8          uint spd = 2000;//速度
   9          uchar acc0 = 0;//加速度
  10          uint n = 0;//直线插补步数
  11          
  12          char rhy0 = 0, rhy1 = 0;//节拍数记录
  13          int X0 = 0, Y0 = 0, Xe = 0, Ye = 0, Xc = 0, Yc = 0;//起始坐标和终止坐标,圆心坐标
  14          int Xi = 0, Yi = 0;     //当前坐标
  15          int Ii = 0, Ji = 0;//圆弧相对圆心坐标
  16          int I0 = 0, J0 = 0;//圆弧起始点
  17          int Iee = 0, Je = 0;//圆弧终止点
  18          int Ir = 0, Jr = 0;//圆弧参考点
  19          int F = 0;//f为斜率判别式
  20          uchar JZe = 0;//终点的斜区间
  21          int angle = 0;//-360~360,逆时针为正
  22          //uchar speed = 0;
  23          bit shape = 1;  //1:直线        0：曲线
  24          bit clcwise = 1;        //1：顺时针     0：逆时针
  25          bit sending;//发送中标志位
  26          bit piflag = 0;//过参考点标记
  27          bit cirendflag = 1;//一组圆弧插补已结束
  28          
  29          void timer_init()
  30          {
  31   1              TMOD = 0x11;//定时器0工作方式1.16位，定时器1工作方式1,16位定时；
  32   1              SCON = 0x50;           //串口工作在模式1
  33   1      
  34   1              TH0 = (65536 - 50000) >> 8;
  35   1              TL0 = (65536 - 50000);
  36   1              TH1 = (65536 - 50000) >> 8;
  37   1              TL1 = (65536 - 50000);
  38   1              TL2 = RCAP2L = (65536 - (FOSC / 32 / BAUD)); //计算定时器重装值
  39   1              TH2 = RCAP2H = (65536 - (FOSC / 32 / BAUD)) >> 8;
  40   1      
  41   1              T2CON = 0x34;           //Timer2 start run
  42   1              TR2 = 1;                //定时器2开始计时
  43   1              TR1 = 0;          //bu启动定时器1
  44   1              ET1 = 1;           //定时器1中断使能
  45   1      
  46   1              TR0 = 0;        //定时器启动标志
  47   1              ET0 = 1;        //定时器中断使能
  48   1              ES = 1;         //串行中断允许
  49   1              
  50   1              EA = 1; //全局中断
  51   1      
  52   1      }
  53          
  54          
C51 COMPILER V9.54   DRIVE                                                                 06/17/2020 18:07:45 PAGE 2   

  55          void send(int d, uchar xy)                //发送2个字节的数据，d待发送数据,xy为坐标标识
  56          {
  57   1              //协议：8位:x轴0 y轴1；低7位数据
  58   1              uchar temp;//低位
  59   1              uchar temp1;//高位
  60   1              if (d >= 0) {
  61   2                      if (xy == 'x') {
  62   3                              temp = d & 0x7f;//0xxx xxxx
  63   3                              temp1 = (d >> 7) & 0x3f;//00xx xxxx
  64   3                      }
  65   2                      else {
  66   3                              temp = d & 0x7f | 0x80;//1xxx xxxx
  67   3                              temp1 = (d >> 7) & 0x3f | 0x80;//10xx xxxx
  68   3                      }
  69   2              }
  70   1              else {
  71   2                      if (xy == 'x') {
  72   3                              temp = -d & 0x7f;//0xxx xxxx
  73   3                              temp1 = (-d >> 7) & 0x3f | 0x40;//01xx xxxx
  74   3                      }
  75   2                      else {
  76   3                              temp = -d & 0x7f | 0x80;//1xxx xxxx
  77   3                              temp1 = (-d >> 7) & 0x3f | 0xc0;//11xx xxxx
  78   3                      }
  79   2              }
  80   1              SBUF = temp; //将数据写入到串口缓冲
  81   1              sending = 1;     //设置发送标志
  82   1              while (sending); //等待发送完毕
  83   1      
  84   1              SBUF = temp1; //将数据写入到串口缓冲
  85   1              sending = 1;     //设置发送标志
  86   1              while (sending); //等待发送完毕
  87   1      }
  88          
  89          void uart(void) interrupt 4              //串口发送中断
  90          {
  91   1              if (RI)    //收到数据
  92   1                      RI = 0;   //清中断请求
  93   1              else      //发送完一字节数据
  94   1              {
  95   2                      TI = 0;
  96   2                      sending = 0;  //清正在发送标志
  97   2              }
  98   1      }
  99          
 100          void stepperA() {
 101   1              
 102   1              A0 = table[rhy0] & 1;
 103   1              A1 = (table[rhy0] >> 1) & 1;
 104   1              A2 = (table[rhy0] >> 2) & 1;
 105   1              A3 = (table[rhy0] >> 3) & 1;
 106   1              if (Xdir) 
 107   1                      rhy0 = rhy0 < 7 ? rhy0 + 1 : 0;
 108   1              else 
 109   1                      rhy0 = rhy0 > 0 ? rhy0 - 1 : 7;
 110   1      }
 111          
 112          void stepperB() {
 113   1              
 114   1              B0 = table[rhy1] & 1;
 115   1              B1 = (table[rhy1] >> 1) & 1;
 116   1              B2 = (table[rhy1] >> 2) & 1;
C51 COMPILER V9.54   DRIVE                                                                 06/17/2020 18:07:45 PAGE 3   

 117   1              B3 = (table[rhy1] >> 3) & 1;
 118   1              if (Ydir) 
 119   1                      rhy1 = rhy1 < 7 ? rhy1 + 1 : 0;
 120   1              else 
 121   1                      rhy1 = rhy1 > 0 ? rhy1 - 1 : 7;
 122   1      }
 123          
 124          void Timer0() interrupt 1  //定时器0中断
 125          {
 126   1              static bit jo = 0;
 127   1              static uint temp = 50000;
 128   1              if (n > 200 && temp > spd)
 129   1                      temp -= acc0;//加速
 130   1              if (n <= 200 && temp < 50000)
 131   1                      temp += acc0;//减速
 132   1              if(!(n > 200 && temp > spd)&&!(n <= 200 && temp < 50000))
 133   1                      temp=spd;
 134   1              TH0 = (65536 - temp) >> 8;
 135   1              TL0 = (65536 - temp);//重新装载计时初
 136   1              if (jo) {//奇数拍
 137   2                      if (n > 0) {
 138   3                              line();//直线插补
 139   3                              n--;
 140   3                      }
 141   2              }
 142   1              else {//偶数拍
 143   2                      if (Xpul) Xpul = 0;     //脉冲下降
 144   2                      if (Ypul) Ypul = 0;
 145   2              }
 146   1              jo = !jo;
 147   1      }
 148          
 149          void Timer1() interrupt 3 {//
 150   1              static bit jo = 0;
 151   1              static uint temp = 50000;
 152   1              if (temp > spd && (abs(Ji - J0) + abs(Ii - I0) < 300)) //速度小且离起点近
 153   1                      temp -= acc0;//加速
 154   1              if (temp < 50000 && (abs(Ji - Je) + abs(Ii - Iee) < 200))
 155   1                      temp += acc0*3;//减速
 156   1              TH1 = (65536 - temp) >> 8;
 157   1              TL1 = (65536 - temp);//重新装载计时初
 158   1              if (jo) {//奇数拍
 159   2                      if (!cirend()) 
 160   2                              cir();//圆弧插补
 161   2                      else cirendflag = 1;//圆弧插补结束
 162   2              }
 163   1              else {//偶数拍
 164   2                      if (Xpul) Xpul = 0;     //脉冲下降
 165   2                      if (Ypul) Ypul = 0;
 166   2              }
 167   1              jo = !jo;
 168   1      }
 169          
 170          void line() {//一次插补
 171   1              if (F >= 0) {
 172   2                      if (Xdir) {
 173   3                              Xi++;
 174   3                              Xpul = 1;//脉冲升高 
 175   3                              stepperA();//寄存器低四位X赋值
 176   3                      }
 177   2                      else {
 178   3                              Xi--;
C51 COMPILER V9.54   DRIVE                                                                 06/17/2020 18:07:45 PAGE 4   

 179   3                              Xpul = 1;//脉冲升高
 180   3                              stepperA();//寄存器低四位X赋值
 181   3                      }
 182   2                      if (Ydir)F -= (Ye - Y0);//判别式
 183   2                      else F -= (Y0 - Ye);
 184   2              }
 185   1              else {
 186   2                      if (Ydir) {
 187   3                              Yi++;
 188   3                              Ypul = 1;//脉冲升高 
 189   3                              stepperB();//寄存器高四位Y赋值
 190   3                      }
 191   2                      else {
 192   3                              Yi--;
 193   3                              Ypul = 1;//脉冲升高 
 194   3                              stepperB();//寄存器高四位Y赋值
 195   3                      }
 196   2                      if (Xdir)F += (Xe - X0);//判别式
 197   2                      else F += (X0 - Xe);
 198   2              }
 199   1      
 200   1      }
 201          
 202          uint getRNS(int X, int Y) {
 203   1              if (clcwise) {  //顺时针
 204   2                      if (X > 0 && Y >= 0)return 1;   //第一象限顺时针
 205   2                      else if (X <= 0 && Y > 0)return 2;//二顺
 206   2                      else if (X < 0 && Y <= 0)return 3;//三顺
 207   2                      else return 4;//四顺    
 208   2              }
 209   1              else {  //逆时针
 210   2                      if (X >= 0 && Y > 0)return 5;//第一象限逆时针
 211   2                      else if (X < 0 && Y >= 0)return 6;//二逆
 212   2                      else if (X <= 0 && Y < 0)return 7;//三逆
 213   2                      else return 8;//四逆
 214   2              }
 215   1      }
 216          void cir(void) {
 217   1              unsigned int temp;
 218   1              temp = getRNS(Ii, Ji);//当前的象限和方向
 219   1              if (F >= 0) {
 220   2                      if (temp == 1 || temp == 6) {
 221   3                              F = F - 2 * (Ji--) + 1;
 222   3                              Ydir = 0;
 223   3                              Ypul = 1;
 224   3                              stepperB();//寄存器高四位Y赋值
 225   3                      }
 226   2                      else if (temp == 2 || temp == 7) {
 227   3                              F = F + 2 * (Ii++) + 1;
 228   3                              Xdir = 1;
 229   3                              Xpul = 1;
 230   3                              stepperA();//寄存器低四位X赋值
 231   3                      }
 232   2                      else if (temp == 3 || temp == 8) {
 233   3                              F = F + 2 * (Ji++) + 1;
 234   3                              Ydir = 1;
 235   3                              Ypul = 1;
 236   3                              stepperB();//寄存器高四位Y赋值
 237   3                      }
 238   2                      else if (temp == 4 || temp == 5) {
 239   3                              F = F - 2 * (Ii--) + 1;
 240   3                              Xdir = 0;
C51 COMPILER V9.54   DRIVE                                                                 06/17/2020 18:07:45 PAGE 5   

 241   3                              Xpul = 1;
 242   3                              stepperA();//寄存器低四位X赋值
 243   3                      }
 244   2              }
 245   1              else {
 246   2                      if (temp == 1 || temp == 8) {
 247   3                              F = F + 2 * (Ii++) + 1;
 248   3                              Xdir = 1;
 249   3                              Xpul = 1;
 250   3                              stepperA();//寄存器低四位X赋值
 251   3                      }
 252   2                      else if (temp == 4 || temp == 7) {
 253   3                              F = F - 2 * (Ji--) + 1;
 254   3                              Ydir = 0;
 255   3                              Ypul = 1;
 256   3                              stepperB();//寄存器高四位Y赋值
 257   3                      }
 258   2                      else if (temp == 2 || temp == 5) {
 259   3                              F = F + 2 * (Ji++) + 1;
 260   3                              Ydir = 1;
 261   3                              Ypul = 1;
 262   3                              stepperB();//寄存器高四位Y赋值
 263   3                      }
 264   2                      else if (temp == 3 || temp == 6) {
 265   3                              F = F - 2 * (Ii--) + 1;
 266   3                              Xdir = 0;
 267   3                              Xpul = 1;
 268   3                              stepperA();//寄存器低四位X赋值
 269   3                      }
 270   2              }
 271   1              Xi = Ii + Xc; 
 272   1              Yi = Ji + Yc;
 273   1      
 274   1      }
 275          
 276          void startline(int xe, int ye) {//直线插补初始化
 277   1              //(x终止坐标，y终止 )
 278   1              //if(Xi!=x0||Yi!=y0)
 279   1              X0 = Xi;
 280   1              Xe = xe;
 281   1              Y0 = Yi; 
 282   1              Ye = ye;
 283   1              F = 0;
 284   1              acc0 = (50000 - spd) / 200;//计算加速度
 285   1              if (xe >= X0) {//判断正反向
 286   2                      Xdir = 1; n = xe - X0;//正向
 287   2              }
 288   1              else {
 289   2                      Xdir = 0; n = X0 - xe;//反向
 290   2              }
 291   1              if (ye >= Y0) {
 292   2                      Ydir = 1; n += ye - Y0;
 293   2              }
 294   1              else {
 295   2                      Ydir = 0; n += Y0 - ye;
 296   2              }
 297   1              TR0 = 1;
 298   1              TR1 = 0;
 299   1      }
 300          void startcir(int xc, int yc, int ang, bit cl) {//圆弧插补初始化
 301   1      //圆心x，圆心y，角度，顺时针1逆时针0
 302   1              TR0 = 0;
C51 COMPILER V9.54   DRIVE                                                                 06/17/2020 18:07:45 PAGE 6   

 303   1              TR1 = 0;
 304   1              piflag = 0;//未经过参考点
 305   1              Xc = xc;//圆心
 306   1              Yc = yc;
 307   1              I0 = Ii = Xi - xc;//起始点
 308   1              J0 = Ji = Yi - yc;
 309   1              clcwise = cl;
 310   1              F = 0;
 311   1              angle = ang;
 312   1              acc0 = (50000 - spd) / 200;//计算加速度
 313   1              //计算终点
 314   1              if (!cl)
 315   1                      Iee =  I0*cos((float)ang * 0.0174533) - J0*sin((float)ang * 0.0174533);
 316   1      
 317   1              else
 318   1                      Iee =  I0*cos((float)ang * 0.0174533) + J0*sin((float)ang * 0.0174533);
 319   1      
 320   1              Je = I0*sin((float)ang * 0.0174533) + J0*cos((float)ang * 0.0174533);
 321   1      
 322   1              Ir = -Iee;//参考点，过了参考点开启终止判别
 323   1              Jr = -Je;
 324   1              //获取终点的J区间
 325   1              
 326   1              JZe=getJ(Iee,Je);
 327   1              
 328   1              ////////////////////////////
 329   1              cirendflag = 0;//正在插补圆弧
 330   1              TR1 = 1;
 331   1              
 332   1      }
 333          
 334          uchar getJ(int irhs,int jrhs) {         //判断J区间                             1
 335   1      
 336   1              if (clcwise) {//顺时针                                                          2               4
 337   2                      if (abs(jrhs) > abs(irhs) || jrhs == -irhs) {//         3
 338   3                              if (jrhs > 0) return 1;
 339   3                              else if (jrhs < 0) return 3;
 340   3                      }
 341   2                      else if (abs(jrhs) < abs(irhs) || jrhs == irhs) {
 342   3                              if (irhs < 0)return 2;
 343   3                              else if (irhs > 0)return 4;
 344   3                      }
 345   2              }
 346   1              else {
 347   2                      if (abs(jrhs) > abs(irhs) || jrhs == irhs) {
 348   3                              if (jrhs > 0) return 1;
 349   3                              else if (jrhs < 0) return 3;
 350   3                      }
 351   2                      else if (abs(jrhs) < abs(irhs) || jrhs == -irhs) {
 352   3                              if (irhs < 0)return 2;
 353   3                              else if (irhs > 0)return 4;
 354   3                      }
 355   2              }
 356   1      }
 357          
 358          bit cirend() {
 359   1              if (!JZe) return 1;
 360   1              if (!piflag && angle > 250) {
 361   2                      if ((Ii - I0) + (Ji - J0) <= ((Ir - I0) + (Jr - J0)) >> 1)//没过参考点
 362   2                              return 0;
 363   2                      else 
 364   2                              piflag = 1;
C51 COMPILER V9.54   DRIVE                                                                 06/17/2020 18:07:45 PAGE 7   

 365   2              }
 366   1      
 367   1              if (JZe == getJ(Ii,Ji)) {       //终点斜区间与当前斜区间相同
 368   2                      if (clcwise) {//顺时针
 369   3                              switch (JZe) {
 370   4                              case 1:
 371   4                                      if (Ii - Iee >= 0)return 1;
 372   4                                      else return 0;
 373   4                              case 2:
 374   4                                      if (Ji - Je >= 0)return 1;
 375   4                                      else return 0;
 376   4                              case 3:
 377   4                                      if (Ii - Iee <= 0)return 1;
 378   4                                      else return 0;
 379   4                              case 4:
 380   4                                      if (Ji - Je <= 0)return 1;
 381   4                                      else return 0;
 382   4                              }
 383   3                      }
 384   2                      else {//逆时针
 385   3                              switch (JZe) {
 386   4                              case 1:
 387   4                                      if (Ii - Iee <= 0)return 1;
 388   4                                      else return 0;
 389   4                              case 2:
 390   4                                      if (Ji - Je <= 0)return 1;
 391   4                                      else return 0;
 392   4                              case 3:
 393   4                                      if (Ii - Iee >= 0)return 1;
 394   4                                      else return 0;
 395   4                              case 4:
 396   4                                      if (Ji - Je >= 0)return 1;
 397   4                                      else return 0;
 398   4                              }
 399   3                      }
 400   2              }
 401   1              else return 0;
 402   1      }
 403          
*** WARNING C291 IN LINE 356 OF code\drive.c: not every exit path returns a value
*** WARNING C291 IN LINE 402 OF code\drive.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2926    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     48      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      7       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
