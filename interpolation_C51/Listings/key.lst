C51 COMPILER V9.54   KEY                                                                   06/04/2020 15:15:13 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\Objects\key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE code\key.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\
                    -key.lst) OBJECT(.\Objects\key.obj)

line level    source

   1          #include"key.h"
   2          //unsigned char code table[]="0123456789abcdef";
   3          
   4          //uchar KeyScan()  //键盘扫描函数，使用行列反转扫描法
   5          //{
   6          //      unsigned char cord_h, cord_l;//行列值
   7          //      P3 = 0x0f;            //行线输出全为0
   8          //      cord_h = P3 & 0x0f;     //读入行值
   9          //      if (cord_h != 0x0f)    //先检测有无按键按下
  10          //      {
  11          //              delay(10);        //去抖
  12          //              if ((P3 & 0x0f) != 0x0f)
  13          //              {
  14          //                      cord_h = P3 & 0x0f;  //读入行值
  15          //                      P3 = cord_h | 0xf0;  //输出当前行值
  16          //                      cord_l = P3 & 0xf0;  //读入列值
  17          //                      while ((P3 & 0xf0) != 0xf0);//等待松开并输出 
  18          //                      return(cord_h + cord_l);//键盘最后组合码值
  19          //              }
  20          //      }
  21          //      return(0xff);  //返回该值
  22          //}
  23          
  24          uchar KeyScan()  //键盘扫描函数，使用行列反转扫描法
  25          {
  26   1              unsigned char cord_h, cord_l;//行列值
  27   1              P3 = 0x0f;            //行线输出全为0
  28   1              cord_h = P3 & 0x0f;     //读入行值
  29   1              if (cord_h != 0x0f)    //先检测有无按键按下
  30   1              {
  31   2                      delay(10);        //去抖
  32   2                      if ((P3 & 0x0f) != 0x0f)
  33   2                      {
  34   3                              cord_h = P3 & 0x0f;  //读入行值
  35   3                              P3 = cord_h | 0xf0;  //输出当前行值
  36   3                              cord_l = P3 & 0xf0;  //读入列值
  37   3                              while ((P3 & 0xf0) != 0xf0);//等待松开并输出
  38   3                              return(cord_h + cord_l);//键盘最后组合码值
  39   3                      }
  40   2              }
  41   1              return(0xff);  //返回该值
  42   1      }
  43          
  44          
  45          
  46          //void display()//主函数
  47          //{
  48          
  49          
  50          //}
  51          
  52          uchar KeyValue()//编码
  53          {
  54   1              switch (KeyScan())
C51 COMPILER V9.54   KEY                                                                   06/04/2020 15:15:13 PAGE 2   

  55   1              {
  56   2                      case 0xee:return '7';  //按下相应的键显示相对应的码值
  57   2                      case 0xde:return '8'; 
  58   2                      case 0xbe:return '9';// 7       8       9       a
  59   2                      case 0x7e:return 'a';// 4       5       6       b 
  60   2                      case 0xed:return '4';// 1       2       3       c 
  61   2                      case 0xdd:return '5';// *       0       #       d 
  62   2                      case 0xbd:return '6'; 
  63   2                      case 0x7d:return 'b'; 
  64   2                      case 0xeb:return '1'; 
  65   2                      case 0xdb:return '2'; 
  66   2                      case 0xbb:return '3'; 
  67   2                      case 0x7b:return 'c'; 
  68   2                      case 0xe7:return '*'; 
  69   2                      case 0xd7:return '0';
  70   2                      case 0xb7:return '#'; 
  71   2                      case 0x77:return 'd'; 
  72   2                      default:return 0xff; 
  73   2              }
  74   1      }
  75          
  76          
  77          void lcd_init()//初始化函数体
  78          {
  79   1              EN = 0;
  80   1              delay(5);
  81   1              lcd_wcom(0x38);//设置16*2显示，5*7点阵，8位数据接口
  82   1              delay(5);
  83   1              lcd_wcom(0x0c);//设置开显示，不显示光标
  84   1              delay(5);
  85   1              lcd_wcom(0x06);//写一个字符时，整屏右移
  86   1              delay(5);
  87   1              lcd_wcom(0x01);//显示清零
  88   1              
  89   1              lcd_wcom(0x80);
  90   1              lcd_wdata('-');//-直线, o圆弧
  91   1              
  92   1              lcd_wcom(0x80+1);
  93   1              lcd_wdata('A');//角度
  94   1              lcd_wdata('n');
  95   1              lcd_wdata('g');
  96   1              lcd_wdata(':');
  97   1              lcd_wdata('0');
  98   1              lcd_wdata('0');
  99   1              lcd_wdata('0');
 100   1              
 101   1              lcd_wcom(0x80+9);
 102   1              lcd_wdata('S');
 103   1              lcd_wdata('p');
 104   1              lcd_wdata('d');
 105   1              lcd_wdata(':');
 106   1              lcd_wdata('0');
 107   1              lcd_wdata('0');
 108   1              
 109   1              lcd_wcom(0x80+0x40);
 110   1              lcd_wdata('X');
 111   1              lcd_wdata(':');
 112   1              lcd_wdata('0');
 113   1              lcd_wcom(0x80+0x40+9);
 114   1              lcd_wdata('Y');
 115   1              lcd_wdata(':');
 116   1              lcd_wdata('0');
C51 COMPILER V9.54   KEY                                                                   06/04/2020 15:15:13 PAGE 3   

 117   1              
 118   1      }
 119          
 120          void lcd_wcom(uchar com)//写命令的函数体
 121          {
 122   1              while (lcd_busy()); //忙则等待
 123   1              RS = 0;
 124   1              RW = 0;
 125   1              EN = 1;
 126   1              P0 = com;
 127   1              _nop_();
 128   1              EN = 0;
 129   1      }
 130          
 131          void lcd_wdata(uchar date)//写数据的函数体
 132          {
 133   1              while (lcd_busy()); //忙则等待
 134   1              RS = 1;
 135   1              RW = 0;
 136   1              EN = 1;
 137   1              P0 = date;
 138   1              _nop_();
 139   1              EN = 0;
 140   1      }
 141          
 142          bit lcd_busy(){
 143   1              P0 = 0xFF;
 144   1              RS = 0;
 145   1              RW = 1;
 146   1              EN = 0;
 147   1              _nop_();
 148   1              EN = 1;
 149   1              return (bit)(P0 & 0x80);
 150   1      }
 151          
 152          //void lcd_xy(uchar x, uchar y)//坐标定位
 153          //{
 154          //      uchar address;
 155          //      if (y == 0)
 156          //              address = 0x80 + x;//y=0,写第一行
 157          //      else
 158          //              address = 0xc0 + x;//y=1,写第二行
 159          //      lcd_wcom(address);
 160          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    390    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
